/// <script>
///  <vs>10.0</vs>
///  <clr>4.0</clr>
///  <fx>4.0</fx>
///  <refs>
///   <ref>$(FxReferenceAssemblyPath)Microsoft.CSharp.dll</ref>
///   <ref>$(FxReferenceAssemblyPath)System.Core.dll</ref>
///   <ref>$(FxReferenceAssemblyPath)System.Data.dll</ref>
///   <ref>$(FxReferenceAssemblyPath)System.dll</ref>
///   <ref>$(FxReferenceAssemblyPath)System.Xml.dll</ref>
///   <ref>$(CodeRunnerPath)CodeRunner.dll</ref>
///   <ref>$(CodeRunnerPath)ToolBelt.dll</ref>
///  </refs>
/// </script>

using System;
using System.Collections.Generic;
using System.Text;
using System.Text.RegularExpressions;
using System.IO;
using CodeRunner;
using ToolBelt;

public class Program
{
	private const string projectName = "ToolBelt";
	private const int projectStartYear = 2011;

	private static string[] fileList = 
	{
		@"ToolBelt\Properties\AssemblyInfo.cs",
		@"Buckle\Properties\AssemblyInfo.cs",
		@"Tests\ToolBelt.UnitTests\Properties\AssemblyInfo.cs",
		@"Toast\Properties\AssemblyInfo.cs", 
		@"Butter\Properties\AssemblyInfo.cs", 
		@"Crumb\Properties\AssemblyInfo.cs", 
		@"ToasterUnitTestPkg\Properties\AssemblyInfo.cs", 
		@"ToasterUnitTestPkg\source.extension.vsixmanifest", 
		@"Toaster\Properties\AssemblyInfo.cs", 
	};

	public static int Main(string[] args)
	{
        if (args.Length != 0 && (args[0] == "-h" || args[0] == "-?"))
		{
            Console.WriteLine("Usage: {0} [<major>.<minor>]\n\nName of solution parent directory will be used as version number if no version specified", 
				ScriptEnvironment.ScriptPath.FileAndExtension);
			return 0;
		}

		ParsedPath projectRoot = GetProjectRootDirectory();

		if (projectRoot == null)
		{
			ConsoleUtility.WriteMessage(MessageType.Error, "Cannot find .sln file to determine project root.");
			return 1;
		}

		Console.WriteLine("Project root is '{0}'", projectRoot);

		// Create all the different version bits
        string versionMajorMinor = args.Length == 0 ? projectRoot.LastDirectoryNoSeparator : args[0];

		if (!Regex.IsMatch(versionMajorMinor, @"[0-9]{1,2}\.[0-9]{1}"))
		{
			ConsoleUtility.WriteMessage(MessageType.Error,
				"Version must be in the form <major>.<minor> where major and minor are numbers and minor is 0 to 9. " + 
				"Correct {0}.", 
				args.Length == 0 ? "solution folder name" : "command line" );
			return 0;
		}
        
		string versionBuild = JDate(projectStartYear);
		string version = String.Format("{0}.{1}.0", versionMajorMinor, versionBuild);
		string versionCsv = version.Replace('.', ',');
		string versionMajorMinorBuild = String.Format("{0}.{1}", versionMajorMinor, versionBuild);
		string versionMajorMinorFull = versionMajorMinor + ".0.0";

		Console.WriteLine("Versions updated:");
		
		foreach (string file in fileList)
		{
			switch (Path.GetExtension(file))
			{
				case ".cs":
					UpdateCSVersion(projectRoot + file, version, versionMajorMinorFull);
					break;
					
				case ".rc":
					UpdateRCVersion(projectRoot + file, version, versionCsv);
					break;

				case ".wxi":
					UpdateWxiVersion(projectRoot + file, versionMajorMinor, versionBuild);
					break;

				case ".wixproj":
				case ".proj":
					UpdateProjVersion(projectRoot + file, versionMajorMinorBuild);
					break;

				case ".vsixmanifest":
					UpdateVsixManifestVersion(projectRoot + file, versionMajorMinorBuild);
					break;

				case ".vcproj":
					UpdateVCProjVersion(projectRoot + file, versionMajorMinorBuild);
					break;

				case ".config":
					UpdateConfigVersion(projectRoot + file, versionMajorMinor);
					break;
			}

			Console.WriteLine("	 {0}{1}", projectRoot, file);
		}
		
		return 0;
	}

	static void UpdateCSVersion(string file, string version, string versionMajorMinorFull)
	{
		string contents = File.ReadAllText(file);

		// Note that we use named substitutions because otherwise Regex gets confused.	"$1" + "1.0.0.0" = "$11.0.0.0".	 There is no $11.
		
		contents = Regex.Replace(
			contents,
			@"(?'before'AssemblyVersion\("")([0-9]+\.[0-9]+\.[0-9]+\.[0-9]+)(?'after'""\))",
			"${before}" + versionMajorMinorFull + "${after}");

		contents = Regex.Replace(
			contents,
			@"(?'before'AssemblyFileVersion\("")([0-9]+\.[0-9]+\.[0-9]+\.[0-9]+)(?'after'""\))",
			"${before}" + version + "${after}");

		File.WriteAllText(file, contents);
	}

	static void UpdateRCVersion(string file, string version, string versionCsv)
	{
		string contents = File.ReadAllText(file);

		contents = Regex.Replace(
			contents,
			@"(?'before'FILEVERSION )([0-9]+,[0-9]+,[0-9]+,[0-9]+)",
			"${before}" + versionCsv);

		contents = Regex.Replace(
			contents,
			@"(?'before'PRODUCTVERSION )([0-9]+,[0-9]+,[0-9]+,[0-9]+)",
			"${before}" + versionCsv);

		contents = Regex.Replace(
			contents,
			@"(?'before'""FileVersion"",[ \t]*"")([0-9]+\.[0-9]+\.[0-9]+\.[0-9]+)(?'after'"")",
			"${before}" + version + "${after}");

		contents = Regex.Replace(
			contents,
			@"(?'before'""ProductVersion"",[ \t]*"")([0-9]+\.[0-9]+\.[0-9]+\.[0-9]+)(?'after'"")",
			"${before}" + version + "${after}");

		File.WriteAllText(file, contents);
	}

	static void UpdateWxiVersion(string file, string versionMajorMinor, string versionBuild)
	{
		string contents = File.ReadAllText(file);

		contents = Regex.Replace(
			contents,
			@"(?'before'" + projectName + @"Version = "")([0-9]+\.[0-9]+)(?'after'"")",
			"${before}" + versionMajorMinor + "${after}");

		contents = Regex.Replace(
			contents,
			@"(?'before'" + projectName + @"Build = "")([0-9]+)(?'after'"")",
			"${before}" + versionBuild + "${after}");

		File.WriteAllText(file, contents);
	}

	static void UpdateVCProjVersion(string file, string versionMajorMinorBuild)
	{
		string contents = File.ReadAllText(file);

		contents = Regex.Replace(
			contents,
			@"(?'before'" + projectName + @"_)([0-9]+\.[0-9]+\.[0-9]+)(?'after'\.msi)",
			"${before}" + versionMajorMinorBuild + "${after}");

		File.WriteAllText(file, contents);
	}

	static void UpdateConfigVersion(string file, string versionMajorMinor)
	{
		// In .config files we are looking for the section that contains an assembly reference 
		// for the section handler.
		string contents = File.ReadAllText(file);

		contents = Regex.Replace(
			contents,
			@"(?'before', +Version=)\d+\.\d+(?'after'\.0\.0 *,)",
			"${before}" + versionMajorMinor + "${after}");

		File.WriteAllText(file, contents);
	}

	static void UpdateProjVersion(string file, string versionMajorMinorBuild)
	{
		string contents = File.ReadAllText(file);

		contents = Regex.Replace(
			contents,
			@"(?'before'<OutputName>" + projectName + @"_)([0-9]+\.[0-9]+\.[0-9]+)(?'after'</OutputName>)",
			"${before}" + versionMajorMinorBuild + "${after}");

		File.WriteAllText(file, contents);
	}

	static void UpdateVsixManifestVersion(string file, string versionMajorMinorBuild)
	{
		string contents = File.ReadAllText(file);

		contents = Regex.Replace(
			contents,
			@"(?'before'<Version>)([0-9]+\.[0-9]+\.[0-9]+)(?'after'</Version>)",
			"${before}" + versionMajorMinorBuild + "${after}");

		File.WriteAllText(file, contents);
	}

	static private ParsedPath GetProjectRootDirectory()
	{
		try
		{
			string rootFile = "*.sln";

			FileInfo[] files = DirectoryUtility.GetFiles(rootFile, SearchScope.RecurseParentDirectories);

			if (files.Length == 0)
			{
				Console.WriteLine("Unable to find file '{0}' to determine project root", rootFile);
				return null;
			}

			return new ParsedPath(files[0].DirectoryName, PathType.Directory);
			// The root directory of the drive will never be the project root
		}
		catch
		{
			return null;
		}
	}

	static private string JDate(int startYear)
	{
		DateTime today = DateTime.Today;
		
		return (((today.Year - startYear + 1) * 10000) + (today.Month * 100) + today.Day).ToString();
	}
}
