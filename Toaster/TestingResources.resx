<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AreEqualDifferentTypesFailMsg" xml:space="preserve">
    <value>Expected:&lt;{1} ({2})&gt;. Actual:&lt;{3} ({4})&gt;. {0}</value>
  </data>
  <data name="AreEqualFailMsg" xml:space="preserve">
    <value>Expected:&lt;{1}&gt;. Actual:&lt;{2}&gt;. {0}</value>
  </data>
  <data name="AssertionFailed" xml:space="preserve">
    <value>{0} failed. {1}</value>
  </data>
  <data name="Common_NullInMessages" xml:space="preserve">
    <value>(null)</value>
  </data>
  <data name="Common_ObjectString" xml:space="preserve">
    <value>(object)</value>
  </data>
  <data name="ExpectedExceptionMustBeException" xml:space="preserve">
    <value>Expected exception on method '{0}' must be derived from Exception</value>
  </data>
  <data name="FailedAllCaps" xml:space="preserve">
    <value>FAILED</value>
  </data>
  <data name="HelpArgumentDescription" xml:space="preserve">
    <value>Shows command line help.</value>
  </data>
  <data name="MethodIgnoredBecauseHasParameters" xml:space="preserve">
    <value>Method '{0}' ignored because it does not have zero parameters</value>
  </data>
  <data name="MethodIgnoredBecauseInstance" xml:space="preserve">
    <value>Method '{0}' ignored because it is not an instance method</value>
  </data>
  <data name="MethodIgnoredBecauseNoTestContext" xml:space="preserve">
    <value>Method '{0}' ignored because it does not have a single TestContext parameter</value>
  </data>
  <data name="MethodIgnoredBecauseNotVoidReturn" xml:space="preserve">
    <value>Method '{0}' ignored because it does not have 'void' return type</value>
  </data>
  <data name="MethodIgnoredBecauseNotStatic" xml:space="preserve">
    <value>Method '{0}' ignored because it is not a static method</value>
  </data>
  <data name="PassedAllCaps" xml:space="preserve">
    <value>PASSED</value>
  </data>
  <data name="PassFailMessage" xml:space="preserve">
    <value>{0} : '{1}'</value>
  </data>
  <data name="SecondAssemblyCleanupFound" xml:space="preserve">
    <value>Second [AssemblyCleanup] method found in class {0}</value>
  </data>
  <data name="SecondAssemblyInitializeFound" xml:space="preserve">
    <value>Second [AssemblyInitialize] method found in class {0}</value>
  </data>
  <data name="SecondClassCleanupFound" xml:space="preserve">
    <value>Second [ClassCleanup] method found in class {0}</value>
  </data>
  <data name="SecondClassInitializeFound" xml:space="preserve">
    <value>Second [ClassInitialize] method found in class {0}</value>
  </data>
  <data name="SecondTestCleanupFound" xml:space="preserve">
    <value>Second [TestCleanup] method found in class {0}</value>
  </data>
  <data name="SecondTestInitializeFound" xml:space="preserve">
    <value>Second [TestInitialize] method found in class {0}</value>
  </data>
  <data name="TestAssemblyCannotBeFound" xml:space="preserve">
    <value>Test assembly '{0}' cannot be found</value>
  </data>
  <data name="TestAssemblyNotSupplied" xml:space="preserve">
    <value>Test assembly not supplied</value>
  </data>
  <data name="TestClassFound" xml:space="preserve">
    <value>Found test class '{0}'</value>
  </data>
  <data name="TestClassHasNoTestMethods" xml:space="preserve">
    <value>Test class '{0}' has no explicit or implicit test methods defined in it.</value>
  </data>
  <data name="TestFileArgumentDescription" xml:space="preserve">
    <value>Assembly containing tests</value>
  </data>
  <data name="TestFileArgumentHint" xml:space="preserve">
    <value>&lt;test-assembly&gt;</value>
  </data>
  <data name="UnableToCreateInstanceOfTestClass" xml:space="preserve">
    <value>Unable to create instance of test class '{0}'. {1}</value>
  </data>
  <data name="DeploymentDirArgumentDescription" xml:space="preserve">
    <value>Directory to deploy the unit test assembly and any assemblies that it requires in order to load.</value>
  </data>
  <data name="DeploymentItemArgumentDescription" xml:space="preserve">
    <value>File which needs to be copied to the same directory as the test assembly before loading the assembly to run tests.</value>
  </data>
  <data name="UnableToCopyFile" xml:space="preserve">
    <value>Unable to copy file '{0}' to '{1}'. {2}</value>
  </data>
  <data name="UnableToCreateDeploymentDirectory" xml:space="preserve">
    <value>Unable to create test deployment directory '{0}'</value>
  </data>
  <data name="UnableToProcessDeploymentItem" xml:space="preserve">
    <value>Unable to process DeploymentItem with path '{0}' and output directory '{1}'.  {2}.</value>
  </data>
  <data name="TestClassArgumentDescription" xml:space="preserve">
    <value>Specifies the full name (including the namespace) of the test class to run.  Only the test methods in this class will be run unless further filtered by the -testname argument.</value>
  </data>
  <data name="TestMethodArgumentDescription" xml:space="preserve">
    <value>Specifies the name (not including namespace and class) of a test method to run.  All this test methods matching this name will run.  Item deployment will be done for all classes unless the -testclass argument is given.  Only explicit test methods (those marked as [TestMethod] can be filtered this way.  </value>
  </data>
  <data name="SkippingTestClass" xml:space="preserve">
    <value>Skipping test class '{0}' because of command line</value>
  </data>
  <data name="SkippingTestMethod" xml:space="preserve">
    <value>Skipping test method '{0}' because of command line</value>
  </data>
  <data name="PropertyArgumentDescription" xml:space="preserve">
    <value>Properties to pass to the test context. Use a semicolon to separate multiple properties.  TestDir and TestDeploymentDir are always set and contain the deployment directory.  A SolutionDir property is automatically set if there is a Visual Studio solution in a parent directory of the test.  When running under the Visual Studio extension Configuration is set to the current build configuration.</value>
  </data>
  <data name="PropertyArgumentHint" xml:space="preserve">
    <value>&lt;name&gt;=&lt;value&gt;</value>
  </data>
  <data name="UnableToLoadTestAssembly" xml:space="preserve">
    <value>Unable to load test assembly '{0}'. {1}</value>
  </data>
  <data name="AreNotEqualFailMsg" xml:space="preserve">
    <value>Expected any value except:&lt;{1}&gt;. Actual:&lt;{2}&gt;. {0}</value>
  </data>
  <data name="ActualHasMismatchedElements" xml:space="preserve">
    <value>The expected collection contains {1} occurrence(s) of &lt;{2}&gt;. The actual collection contains {3} occurrence(s). {0}</value>
  </data>
  <data name="BothCollectionsSameElements" xml:space="preserve">
    <value>Both collection contain same elements.</value>
  </data>
  <data name="BothCollectionsSameReference" xml:space="preserve">
    <value>Both collection references point to the same collection object. {0}</value>
  </data>
  <data name="CollectionEqualReason" xml:space="preserve">
    <value>{0}({1})</value>
  </data>
  <data name="ElementNumbersDontMatch" xml:space="preserve">
    <value>The number of elements in the collections do not match. Expected:&lt;{1}&gt;. Actual:&lt;{2}&gt;.{0}</value>
  </data>
  <data name="ElementsAtIndexDontMatch" xml:space="preserve">
    <value>Element at index {0} do not match.</value>
  </data>
  <data name="IsInstanceOfFailMsg" xml:space="preserve">
    <value>{0}Expected type:&lt;{1}&gt;. Actual type:&lt;{2}&gt;.</value>
  </data>
  <data name="NullParameterToAssert" xml:space="preserve">
    <value>The parameter '{0}' is invalid. The value cannot be null. {1}.</value>
  </data>
  <data name="NumberOfElementsDiff" xml:space="preserve">
    <value>Different number of elements.</value>
  </data>
  <data name="OutputFileArgumentDescription" xml:space="preserve">
    <value>The name of a file to write the XML test results to. If not specified the output will be written to the standard output stream.</value>
  </data>
  <data name="RuntimeVersion" xml:space="preserve">
    <value>Process running {0} CLR {1} from '{2}'.</value>
  </data>
  <data name="TestClassRunning" xml:space="preserve">
    <value>Running test class '{0}'</value>
  </data>
  <data name="UnableToWriteOutputFile" xml:space="preserve">
    <value>Unable to write test result output to file '{0}'. {1}</value>
  </data>
  <data name="WordSize32" xml:space="preserve">
    <value>32-bit</value>
  </data>
  <data name="WordSize64" xml:space="preserve">
    <value>64-bit</value>
  </data>
  <data name="DebugArgumentDescription" xml:space="preserve">
    <value>Attach the just-in-time debugger to the test process before running the first test.  You must still set a breakpoint in the test in order to stop the debugger in it.</value>
  </data>
  <data name="TestMethodRunning" xml:space="preserve">
    <value>Running test method '{0}'</value>
  </data>
  <data name="UnableToReflectAssemblyTypes" xml:space="preserve">
    <value>Unable to reflect on types in assembly '{0}'</value>
  </data>
  <data name="ArgumentArgumentDescription" xml:space="preserve">
    <value>Program arguments</value>
  </data>
  <data name="ArgumentArgumentHint" xml:space="preserve">
    <value>&lt;arguments&gt;</value>
  </data>
  <data name="InstrumentArgumentDescription" xml:space="preserve">
    <value>Additional binary to instrument for coverage. Can be specified multiple times.</value>
  </data>
  <data name="InstrumentArgumentHint" xml:space="preserve">
    <value>&lt;assembly&gt;</value>
  </data>
  <data name="KeyFileArgumentDescription" xml:space="preserve">
    <value>Public/private key file to use for resigning strongly named assembly after coverage instrumentation.</value>
  </data>
  <data name="KeyFileArgumentHint" xml:space="preserve">
    <value>&lt;key-file&gt;</value>
  </data>
  <data name="ProgramArgumentDescription" xml:space="preserve">
    <value>Program to run and collect coverage for</value>
  </data>
  <data name="ProgramArgumentHint" xml:space="preserve">
    <value>&lt;program&gt;</value>
  </data>
  <data name="DeploymentItemDoesNotExist" xml:space="preserve">
    <value>Deployment item '{0}' does not exist</value>
  </data>
  <data name="CannotFindExeInToolDirs" xml:space="preserve">
    <value>Cannot find '{0}' in any given tool directory</value>
  </data>
  <data name="CannotFindExeInPathDirs" xml:space="preserve">
    <value>Cannot find '{0}' in any PATH directory</value>
  </data>
  <data name="ToolDirArgumentDescription" xml:space="preserve">
    <value>Directory containing location of tools to use.  The tools required are vsinstr.exe, vsperfmon.exe, sn.exe, gacutil.exe and ngen.exe.  Multiple tool directories can be specified by using the argument multiple times.  Directories will be searched in the order specified.</value>
  </data>
  <data name="ToolDirArgumentHint" xml:space="preserve">
    <value>&lt;tool-dir&gt;</value>
  </data>
  <data name="ErrorRunningTool" xml:space="preserve">
    <value>An error occurred running a tool as follows: {0} {1}</value>
  </data>
  <data name="FxToolDirArgumentDescription" xml:space="preserve">
    <value>.NET Framework SDK directory containing strong name signing tool to use for resigning.</value>
  </data>
  <data name="FxToolDirArgumentHint" xml:space="preserve">
    <value>&lt;fx-tool-dir&gt;</value>
  </data>
  <data name="AssemblyHasAStrongNameAndNoKeyFile" xml:space="preserve">
    <value>Assembly '{0}' has a strong name and no keyfile was provided.  Assuming verification skipping is enabled.</value>
  </data>
  <data name="NoCoverageDeploymentItemsSpecified" xml:space="preserve">
    <value>No deployment items specified to instrument for coverage.</value>
  </data>
  <data name="DeploymentItemSymbolsDoNotExist" xml:space="preserve">
    <value>Deployment item symbols '{0}' do not exist</value>
  </data>
  <data name="CreatingTemporaryDirectories" xml:space="preserve">
    <value>Creating temporary directories</value>
  </data>
  <data name="DeletingTemporaryDirectories" xml:space="preserve">
    <value>Deleting temporary directories</value>
  </data>
  <data name="InstrumentBinaries" xml:space="preserve">
    <value>Instrument Binaries for Coverage</value>
  </data>
  <data name="RunUnitTests" xml:space="preserve">
    <value>Run Unit Tests</value>
  </data>
  <data name="SavingOriginalBinaries" xml:space="preserve">
    <value>Saving original binaries</value>
  </data>
  <data name="StartCoverageMonitor" xml:space="preserve">
    <value>Start Coverage Monitor</value>
  </data>
  <data name="StopCoverageMonitor" xml:space="preserve">
    <value>Stop Coverage Monitor</value>
  </data>
  <data name="TestAssemblyLoaded" xml:space="preserve">
    <value>Loaded test assembly '{0}'</value>
  </data>
  <data name="UsingExeFrom" xml:space="preserve">
    <value>Using '{0}' from directory '{1}'</value>
  </data>
  <data name="AssemblySearchDirArgumentDescription" xml:space="preserve">
    <value>Additional directory to search for missing assemblies during assembly loads.  Can be specified multiple times.</value>
  </data>
  <data name="AssemblySearchDirArgumentHint" xml:space="preserve">
    <value>&lt;assembly-dir&gt;</value>
  </data>
  <data name="DeploymentDirIsTestAssemblyDir" xml:space="preserve">
    <value>No deployment directory given, using test assembly directory.</value>
  </data>
  <data name="LoadedAssembly" xml:space="preserve">
    <value>Loaded assembly '{0}'</value>
  </data>
  <data name="LoadedAssemblyFrom" xml:space="preserve">
    <value>Loaded assembly '{0}' from {1} '{2}'</value>
  </data>
  <data name="ProblemProcessingTestAssembly" xml:space="preserve">
    <value>Problem processing test assemblies looking for test methods :  {0}</value>
  </data>
  <data name="DeploymentDirectoryMustBeSpecified" xml:space="preserve">
    <value>A deployment directory must be specified.</value>
  </data>
  <data name="UpdateGlobalAssemblyCache" xml:space="preserve">
    <value>Update Global Assembly Cache</value>
  </data>
  <data name="UpdateNativeImageCache" xml:space="preserve">
    <value>Update Native Image Cache</value>
  </data>
  <data name="AssemblyFileArgumentDescription" xml:space="preserve">
    <value>Name of the assembly file for which the display name is desired.</value>
  </data>
  <data name="AssemblyFileArgumentHint" xml:space="preserve">
    <value>&lt;assembly-file&gt;</value>
  </data>
  <data name="CrumbCommandLineDescription" xml:space="preserve">
    <value>Determines the display name (also known as the strong name or full name) of a .NET assembly.</value>
  </data>
  <data name="ButterCommandLineDescription" xml:space="preserve">
    <value>Loads and runs unit test assemblies and collects coverage data using VSTS coverage tools.  The environment variable BUTTER_TOOLPATH can be set to a semi-colon separated list of directories that will be searched in order for the tools needed during coverage instrumentation.  These tools are vsinstr.exe, vsperfcmd.exe, sn.exe, crumb.exe, chgmvid.exe, gacutil.exe, ngen.exe and toast.exe.  BUTTER_KEYFILE can be set to the name of the keyfile to use for resigning if the assemblies are fully signed.  If assemblies are partially signed or not strongly named this environment variable does not need to be set.  Butter's command line is intentionally identical to toast.exe.</value>
  </data>
  <data name="ButterCommandLineExample" xml:space="preserve">
    <value>butter -deploymentdir:TestResults MyUnitTests.dll</value>
  </data>
  <data name="ButterCommandLineTitle" xml:space="preserve">
    <value>Buttered Toast Unit Test Tool for .NET</value>
  </data>
  <data name="CommandLineDebugConfig" xml:space="preserve">
    <value>Debug</value>
  </data>
  <data name="CommandLineReleaseConfig" xml:space="preserve">
    <value>Release</value>
  </data>
  <data name="JohnLyonSmithCopyright" xml:space="preserve">
    <value>Copyright (c) 2010 John Lyon-Smith.  All rights reserved.</value>
  </data>
  <data name="ToastCommandLineDescription" xml:space="preserve">
    <value>Loads and runs unit test assemblies. </value>
  </data>
  <data name="ToastCommandLineExample" xml:space="preserve">
    <value>toast -deploymentdir:TestResults MyUnitTests.dll</value>
  </data>
  <data name="ToastCommandLineTitle" xml:space="preserve">
    <value>Toast Unit Test Tool for .NET</value>
  </data>
  <data name="FailureRunning" xml:space="preserve">
    <value>Failure running '{0}'.\n{1}</value>
  </data>
  <data name="FailureRunningNoOutput" xml:space="preserve">
    <value>Failure running '{0}'.</value>
  </data>
  <data name="CoverageDeploymentItemArgumentDescription" xml:space="preserve">
    <value>File which needs to be copied to the same directory as the test assembly before loading the assembly to run tests AND instrumented for coverage.</value>
  </data>
  <data name="CoverageDeploymentItemMustBeExecutable" xml:space="preserve">
    <value>Coverage deployment item '{0}' must be an executable file</value>
  </data>
  <data name="UnitTestsFailedToRun" xml:space="preserve">
    <value>Unit tests failed to run.</value>
  </data>
</root>